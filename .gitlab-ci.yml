---
variables:  # global variables applying to all jobs unless explicitly overwritten
    REQUESTS_CA_BUNDLE: /etc/ssl/certs/ca-certificates.crt  # this tells python to actually use the installed system certificates

.default run rules:
    rules:  # determine if job should run or not; evaluation stops at the first matching rule!
        - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'  # in general, do run on a MR
        - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'  # do not run for a branch if there is also a MR for that branch - this prevents running two pipelines for the same commit
          when: never
        - if: '$CI_PIPELINE_SOURCE == "schedule"'  # do not run on schedule, we want to do this explicitly on the job
          when: never
        - if: '$CI_COMMIT_BRANCH == "main"'  # if we get here the trigger was not a MR, in that case we only want to run for commits on branch main right now
        - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+(?:-\w+)*$/'  # also run for version tags

workflow:
    rules:
        - if: '$CI_PIPELINE_SOURCE == "schedule"'  # run on schedule
        - !reference [.default run rules, rules]

default:  # default settings applying to all jobs unless explicitly overwritten
    image: rust:latest
    tags:
        - egfx  # this tag will be used to automatically select the Gitlab runner configured for our group

stages:  # stages are executed in the order they are defined; if no direct dependencies between jobs are defined, all jobs of a stage need to finish successfully before the next stage begins
    - Build Rust
    - Test Rust
    - Lint Rust
    - Lint
    - Audit Rust
    - Generate Deno bindings
    - Publish

.setup rust:
    before_script:
        - rustc --version
        - cargo --version

.setup wasm-pack:
    before_script:
        - curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
        - wasm-pack --version

Build Rust Code:
    stage: Build Rust
    before_script:
        - !reference [.setup rust, before_script]
        - !reference [.setup wasm-pack, before_script]
    script:
        - wasm-pack build --release
        - 'WASM_BINDGEN=`[[ -z "${XDG_CACHE_HOME}" ]] && find $HOME/.cache -name wasm-bindgen || find $HOME/.cache $XDG_CACHE_HOME -name wasm-bindgen`'
        - '[[ -z "${WASM_BINDGEN}" ]] && echo wasm-bindgen not found && (exit 1)'
        - 'cp $WASM_BINDGEN .'
    rules:
        - !reference [.default run rules, rules]
    artifacts:
        paths:
            - "target/wasm32-unknown-unknown/release/wasm_minisign_verify.wasm"
            - "wasm-bindgen"
        expire_in: 2 hours

Generate Deno bindings:
    stage: Generate Deno bindings
    variables:
        GIT_STRATEGY: none
    script:
        - './wasm-bindgen --target deno --typescript --out-dir pkg target/wasm32-unknown-unknown/release/wasm_minisign_verify.wasm'
    rules:
        - !reference [.default run rules, rules]
    dependencies:
        - "Build Rust Code"
    artifacts:
        paths:
            - "pkg"
        expire_in: 2 hours

Test Rust Code:
    stage: Test Rust
    before_script:
        - !reference [.setup rust, before_script]
    script:
        - cargo test --verbose
    needs: ["Build Rust Code"]
    rules:
        - !reference [.default run rules, rules]

Lint Rust Code with Clippy:
    stage: Lint Rust
    before_script:
        - !reference [.setup rust, before_script]
    script:
        - rustup component add clippy
        - cargo clippy -- -D warnings
    needs: ["Build Rust Code"]
    rules:
        - !reference [.default run rules, rules]

Check Rust code formatting:
    stage: Lint Rust
    before_script:
        - !reference [.setup rust, before_script]
    script:
        - rustup component add rustfmt
        - cargo fmt -- --check
    needs: ["Build Rust Code"]
    rules:
        - !reference [.default run rules, rules]

Audit Rust dependencies:
    stage: Audit Rust
    before_script:
        - !reference [.setup rust, before_script]
    script:
        - cargo install cargo-audit
        - cargo audit
    needs: []
    rules:  # determine if job should run or not; evaluation stops at the first matching rule!
        - if: '$CI_PIPELINE_SOURCE == "schedule"'  # run on schedule
        - !reference [.default run rules, rules]

Lint CI:
    image: artifacts.core.pke.fhm.de/peo-docker-public-local/python:3
    stage: Lint
    before_script:
        - pip install yamllint
    script:
        - "yamllint .gitlab-ci.yml"
    needs: []
    rules:
        - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "push"'
          changes:  # run if any of the following changes on a MR or push
              - '.gitlab-ci.yml'
        - if: '$CI_PIPELINE_SOURCE != "merge_request_event" && $CI_PIPELINE_SOURCE != "push" && $CI_PIPELINE_SOURCE != "schedule"'
          when: on_success  # always run for other pipeline sources

Publish version to Artifactory (exact version):
    stage: Publish
    image: $ARTIFACTORY_FQDN/peo-docker-public-local/alpine:3.15  # alpine image with P7S1 SSL certificates preinstalled
    variables:
        GIT_DEPTH: 1
    before_script:
        - command -v md5sum &> /dev/null  # check if md5sum is available
        - command -v sha1sum &> /dev/null  # check if sha1sum is available
        - command -v sha256sum &> /dev/null  # check if sha256sum is available
        - command -v awk &> /dev/null  # check if awk is available
        - apk add --no-cache curl
        - command -v curl &> /dev/null  # check if curl is available
        - curl -fL https://install-cli.jfrog.io | sh  # install Jfrog CLI
        - jf config import $ARTIFACTORY_CONFIG_BASE64  # load prepared configuration
        - jf rt ping  # test if we can connect
        - apk add --no-cache git
    script:
        - cd pkg/
        - jf rt upload --flat=false --quiet --recursive "*" egfx-generic-public-local/deno_modules/wasm-minisign-verify@`git tag --points-at HEAD`/
    dependencies:
        - "Generate Deno bindings"
    rules:
        - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+(?:-\w+)*$/'  # also run for version tags

Publish version to Artifactory (latest):
    stage: Publish
    image: $ARTIFACTORY_FQDN/peo-docker-public-local/alpine:3.15  # alpine image with P7S1 SSL certificates preinstalled
    variables:
        GIT_STRATEGY: none  # do not clone repo, we only want to talk to Artifactory anyway
    before_script:
        - command -v md5sum &> /dev/null  # check if md5sum is available
        - command -v sha1sum &> /dev/null  # check if sha1sum is available
        - command -v sha256sum &> /dev/null  # check if sha256sum is available
        - command -v awk &> /dev/null  # check if awk is available
        - apk add --no-cache curl
        - command -v curl &> /dev/null  # check if curl is available
        - curl -fL https://install-cli.jfrog.io | sh  # install Jfrog CLI
        - jf config import $ARTIFACTORY_CONFIG_BASE64  # load prepared configuration
        - jf rt ping  # test if we can connect
    script:
        - cd pkg/
        - jf rt upload --flat=false --quiet --recursive --sync-deletes=egfx-generic-public-local/wasm-minisign-verify/ "*" egfx-generic-public-local/deno_modules/wasm-minisign-verify/
    dependencies:
        - "Generate Deno bindings"
    rules:
        - if: '$CI_COMMIT_TAG =~ /^\d+\.\d+\.\d+$/'  # also run for version tags
